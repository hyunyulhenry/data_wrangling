--- 
title: "R을 이용한 "
author: "이현열 (Henry Lee)"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
fontsize: 12pt
link-citations: yes
latex_engine: xelatex
github-repo: hyunyulhenry/data_wrangling
---
```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```

# Welcome {-}

본 페이지는 **R을 이용한 데이터 랭글링** 강의 페이지이며, 다음과 같은 내용으로 구성되었습니다.

- Part 1: 데이터 타입별 다루기
  - Chapter 1: Numbers
  - Chapter 2: Character Strings
  - Chapter 3: Factors
  - Chapter 4: Date
- Part 2: 데이터 구조 다루기
  - Chapter 5: Data Structure Basics
  - Chapter 6: Vector
  - Chapter 7: List
  - Chapter 8: Matrix
  - Chapter 9: Data Frame
  - Chapter 10: Missing Value
- Part 3: 데이터 불러오기 및 내보내기
  - Chapter 11: Import Data
  - Chapter 12: Exporting Data
- Part 4: 데이터 구조 변형하기
  - Chapter 13: 함수
  - Chapter 14: Loop Statement
  - Chapter 15: Pipe Operator (%>%)
- Part 5: 데이터 구조 변형하기
  - Chapter 16: tidyr을 이용한 데이터 모양 바꾸기
  - Chapter 17: dplyr을 이용한 데이터 변형하기

본 강의록의 대부분 내용은 *Bradley C. Boehmke*의 **Data Wrangling with R (Use R!)**을 참조하였습니다.

https://www.amazon.com/Data-Wrangling-R-Use/dp/3319455982

```{r echo = FALSE, out.width = '30%'}
knitr::include_graphics('images/user_cover.jpg')
```

## Contact Information {-}

- E-mail: leebisu@gmail.com
- Henry’s Quantopia: https://blog.naver.com/leebisu
- GitHub: https://github.com/hyunyulhenry/

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# (PART) 데이터 타입별 다루기 {-}

# Numbers

R에서 숫자 형태는 크게 integer와 double로 나눌 수 있습니다. 이 중 integer는 정수를 의미하며, double은 부동소수점 실수를 의미합니다.

## integer와 double의 vector 만들기

먼저 double 형태의 벡터를 만듭니다.

```{r}
dbl_var = c(1, 2.5, 4.5)
dbl_var
```

숫자 뒤에 L을 붙이면 integer(정수) 형태로 입력됩니다.

```{r}
int_var = c(1L, 6L, 10L)
int_var
```

### 둘 간의 형태 바꾸기

`as.*()` 함수를 이용해 각 데이터의 형태(Type)을 바꿀 수 있습니다.

```{r}
as.double(int_var)
# as.numeric(int_var)
```

`as.double()` 함수를 통해 integer 형태를 double 형태로 바꿀 수 있습니다. `as.numeric()` 함수는 `as.double()`과 동일한 역할을 합니다.

```{r}
as.integer(dbl_var)
```

`as.integer()` 함수를 통해 double 형태를 integer 형태로 바꿀 수 있습니다. 소수점이 사라지고 정수형태로 바뀌었습니다.

## 비임의(Non-random) 숫자 생성하기

콜론(:)과 `c()` 함수를 통해 순서가 있는 숫자 벡터를 생성할 수 있습니다.

```{r}
1:10
```

콜론을 통해 1에서 10까지 숫자가 생성됩니다.

```{r}
c(1, 5, 10)
```

`c()` 함수 내부에 입력한 숫자로 벡터가 생성됩니다.

### `seq()` 함수 이용

`seq()` 함수를 이용할 경우 더욱 다양하게 숫자 벡터를 생성할 수 있습니다.

```{r}
seq(from = 1, to = 21, by = 2)
```

from에는 시작 숫자, to에는 종료 숫자, by에는 간격을 입력합니다. 즉 1에서 21까지 2 단위로 숫자가 생성됩니다.

```{r}
seq(0, 21, length.out = 15)
```

인자에 length.out을 쓸 경우 from에서 to까지 동일한 증가폭으로 15개의 숫자를 생성합니다.

```{r}
rep(1: 4)
```

`rep()` 함수 역시 `seq()` 함수와 비슷한 역할을 합니다.

```{r}
rep(1:4, times = 2)
```

times 인자를 추가해줄 경우, 해당 숫자만큼 반복되어 벡터가 생성됩니다.

```{r}
rep(1:4, each = 2)
```

each 인자를 추가할 경우, 각 숫자를 n번 반복하여 벡터가 생성됩니다.

## 임의(Random) 숫자 생성하기

이번에는 임의의 숫자를 생성하는 방법에 대해 알아보겠습니다.

### Uniform Numbers

균등 분포(Uniform distribution)에서 임의의 숫자를 생성하기 위해서는 `runif()` 함수를 사용합니다.

```{r}
runif(5)
```

기본적으로 `runif()` 함수는 0과 1사이에서 임의의 숫자를 생성하며, 괄호 안에 입력된 숫자만큼의 갯수의 난수를 생성합니다.

```{r}
runif(5, min = 0, max = 25)
```

min과 max인자를 추가할 경우 해당 값 사이에서 난수를 생성합니다.

`sample()` 함수 역시 Uniform Number를 생성할 수 있습니다.

```{r}
sample(0:25, 10, replace = TRUE)
```

0에서 25까지 숫자중에서 10개의 숫자를 선택하며, replace를 TRUE로 할 경우 복원추출, FALSE로 할 경우 비복원추출을 시행합니다.

### Non-Uniform Numbers

비균등 확률 분포에서 난수를 생성하기 위해서는 크게 4가지 함수가 있습니다.

- r*: 난수 생성
- d*: 밀도(Density) 혹은 확률 질량 함수(Probability mass function)
- p*: 누적 분포(Cumulative distribution)
- q*: 분위수(Quantile)

#### 정규 분포(Normal Distribution)

R에서 정규 분포 관련 함수는 `*norm()` 입니다.

```{r echo = FALSE}
library(ggplot2)

x = seq(from = -3, to = 3, length.out = 100)
y = dnorm(x, mean  = 0, sd = 1)
df = data.frame(x, y)
ggplot(data = df, aes(x = x, y = y)) +
  geom_line() +
  xlab('Unit Normal Variable') +
  ylab('Probability') +
  geom_ribbon(
    data = subset(df, x <= 0),
    aes(ymax = y),
    ymin = 0,
    fill = "blue",
    colour = NA,
    alpha = 0.2
  ) +
  annotate("text", x = 0, y = 0.15, label = "N(d)") +
  geom_segment(data= df, mapping=aes(x=1, y=0.1, xend=0, yend=0),
               arrow=arrow(), size = 1, color="blue") +
  annotate("text", x = 1.1, y = 0.12, label = "d") +
  ggtitle('Cumulative Standard Normal') +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0, 0.1, 0)) 
```

```{r}
rnorm(10, mean = 0, sd = 1)
```

`rnorm()` 함수를 이용하여 평균이 0, 표준편차가 1인 정규분포 함수에서 난수 10개를 생성합니다.

```{r}
dnorm(0, mean = 0, sd = 1)
```

d = 0인 지점의 밀도를 계산합니다.

```{r}
pnorm(0, mean = 0, sd = 1)
```
d = 0인 지점의 누적 분포를 구합니다.

```{r}
qnorm(0.5, mean = 0, sd = 1)
```
누적 분포가 0.5인 지점의 분위수를 구합니다.

#### 기타 분포

정규 분포 외에도 여러 분포에서 난수를 생성할 수 있습니다. 각 함수별 인자는 `help()`를 통해 확인할 수 있습니다.

- 이항 분포: rbinom, dbinom, pbinom, qbinom
- 푸아송 분포: rpois, dpois, ppois, qpois
- 지수 분포: rexp, dexp, pexp, qexp
- 감마 분포: rgamma, dgamma, pgamma, qgamma

## 반올림

숫자의 올림, 내림, 반올림 등을 실행합니다. 먼저 다음과 같이 숫자를 입력합니다.

```{r}
x = c(1, 1.35, 1.7, 2.05, 2.4, 2.75, 3.1, 3.45, 3.8, 4.15, 
      4.5, 4.85, 5.2, 5.55, 5.9)
```

```{r}
round(x)
```

`round()` 함수는 가장 가까운 정수로 반올림을 합니다.

```{r}
round(x, digits = 2)
```

함수 내부에 digits 인자를 추가해 줄 경우, 해당 자리수 만큼 반올림을 합니다.

```{r}
ceiling(x)
```

`ceiling()` 함수는 올림을 실행합니다.

```{r}
floor(x)
```
`floor()` 함수는 내림을 실행합니다.

<!--chapter:end:number.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Character Strings

문자열은 R의 기본함수 및`stringr` 패키지를 이용해 쉽게 다룰 수 있습니다.

## 문자열 기본

```{r}
a = 'learning to create'
b = 'character strings'
paste(a, b)
```

`paste()` 함수를 이용해 두 문자를 붙일 수 있습니다.

```{r}
paste('pi is', pi)
```

R에서 pi는 숫자로 입력되어 있으며, `paste()` 함수를 통해 문자열과 숫자를 붙일수도 있습니다.

```{r}
paste('I', 'love', 'R', sep = '-')
```

sep 인자를 추가할 경우, 각 단어를 구분하는 문자를 입력할 수 있습니다.

```{r}
paste0('I', 'love', 'R')
```

`paste0()` 함수는 구분 문자가 없이 결합됩니다.

## 문자열 출력

문자를 출력하는데 다음과 같은 함수가 있습니다.

- `print()`: 기본적인 출력 함수
- `noquote()`: 쿼트("") 생략
- `cat()`: 문자열 결합 및 쿼트 생략

```{r}
x = 'learning to print strings'
print(x)
print(x, quote = 'FALSE')
```

`print()` 함수를 이용해 기본적인 출력을 할 수 있으며, quote 인자를 FALSE로 지정하여 쿼트를 생략할 수도 있습니다.

```{r}
noquote(x)
```

`noquote()` 함수를 이용할 경우 쿼트가 출력되지 않습니다.

```{r}
cat(x)
cat(x, 'in R')
```

`cat()` 함수를 이용할 경우도 출력이 가능하며, 여러 문자를 결합한 뒤 출력하는 것 또한 가능합니다.

## 문자열 갯수 확인

```{r}
x = 'How many elements are in this string?'

length(x)
```

`length()` 함수의 경우 element의 갯수를 세므로, 1이 출력됩니다.

```{r}
nchar(x)
```

반면 `nchar()` 함수를 이용하여 문장 내 문자의 갯수를 셀 수 있습니다.

## `stringr` 패키지를 이용한 문자열 다루기

R의 기본함수를 이용하여도 문자열을 다룰 수 있지만, `stringr` 패키지를 이용할 경우 더욱 작업을 수행할 수 있습니다.

### 기본 사용법

```{r}
library(stringr)

str_c('Learning', 'to', 'use', 'the', 'stringr', 'package')
```

`str_c()` 함수는 `paste0()`와 기능이 동일합니다.

```{r}
library(stringr)

str_c('Learning', 'to', 'use', 'the', 'stringr', 'package', sep = ' ')
```

sep 인자를 통해 구분자를 추가할 수 있으며, 이는 `paste()`와 동일합니다.

```{r}
text = c('Learning', 'to', NA, 'use', 'the', NA, 'stringr', 'package')

str_length(text)
```

`str_length()` 함수는 문자의 갯수를 셉니다.

```{r}
x = 'Learning to use the stringr package'

str_sub(x, start = 1, end = 15)
```

`str_sub()` 함수는 start부터 end까지의 문자를 출력합니다.

```{r}
str_sub(x, start = -7, end = -1)
```

start 혹은 end에 음수를 입력하면, 문장의 맨 끝에서부터 start/end 지점이 계산됩니다.

```{r}
str_dup('beer', times = 3)
```

`str_dub()` 함수를 이용해 특정 문자를 반복되게 출력할 수 있습니다.

### 공백(Whitespace) 제거

텍스트 데이터를 다룰때는 빈 공백이 따라오는 경우가 많으며, 데이터분석의 편이를 위해 이를 제거해야 합니다.

```{r}
text = c('Text ', ' with', ' whitespace ', ' on', 'both ', 'sides ')

print(text)
```

각 단어의 좌/우 혹은 양쪽에 공백이 있습니다.

```{r}
str_trim(text, side = 'left')
str_trim(text, side = 'right')
str_trim(text, side = 'both')
```

`str_trim()` 함수를 통해 좌/우/양쪽의 공백을 제거할 수 있습니다.

### 문자열 자리수 채우기

원하는 자리수를 채우기 위해 문자열에 공백 혹은 특정 문자를 입력할 수 있습니다.

```{r}
str_pad('beer', width = 10, side = 'left')
```

10자리를 맞추기 위해 좌측에 공백이 추가되었습니다.

```{r}
str_pad('beer', width = 10, side = 'left', pad = '!')
```

pad 인자를 추가할 경우, 공백이 아닌 해당 문자가 추가됩니다.




<!--chapter:end:character.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Factors

R에서 Factor 형태는 범주형(categorical) 데이터를 다룰때 사용됩니다.

## 팩터 생성 및 탐색

```{r}
gender = factor(c('male', 'female', 'female', 'male', 'female'))
gender
```

`factor()` 함수를 통해 팩터를 생성하며, Levels에는 값들의 고유값인 female과 male이 설정되어 있습니다.

```{r}
unclass(gender)
levels(gender)
summary(gender)
```

female은 1, male은 2의 integer가 매칭되어 있으므로, `unclass()` 함수를 이용하여 대표값을 출력할 수 있습니다. 또한 `levels()` 함수를 이용해 레벨을 출력할 수 있으며, `summary()` 함수를 이용할 경우 각 레벨의 빈도가 출력됩니다.

## 레벨에 순서 부여하기

```{r}
gender = factor(c('male', 'female', 'female', 'male', 'female'))
gender
```

레벨을 정의하지 않을 시, 알파벳 순서인 female, male의 순서로 레벨이 정의됩니다.

```{r}
gender = factor(c('male', 'female', 'female', 'male', 'female'),
                levels = c('male', 'female'))
gender
```

반면 levels 인자를 입력하면, 레벨의 순서가 정의됩니다.

```{r}
ses = c('low', 'middle', 'low', 'low', 'low', 'low', 'middle', 'low', 'middle',
        'middle', 'middle', 'middle', 'middle', 'high', 'high', 'low', 'middle',
        'middle', 'low', 'high')

ses = factor(ses, levels = c('low', 'middle', 'high'), ordered = TRUE)
ses
```

또한 ordered 인자를 TRUE로 지정할 시, levels의 크기도 정의됩니다.

## 순서 재정의

```{r}
library(forcats)

fct_recode(ses, small = 'low', medium = 'middle', large = 'high')
```

`forcats` 패키지의 `fct_recode()` 함수를 이용해 팩터의 레벨을 재입력 할 수 있습니다. 이 외에도 해당 패키지에는 팩터를 다룰수 있는 다양한 함수가 존재합니다.


<!--chapter:end:factor.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Date

날짜, 시간에 관련된 데이터는 R의 기본함수 및 `lubridate` 패키지를 이용해 쉽게 다룰 수 있습니다.

## 현재 날짜 및 시간 

```{r}
Sys.timezone()
Sys.Date()
Sys.time()
```

기본 함수를 통해 현재 타임존 및 날짜, 시간을 확인할 수 있습니다.

## 문자열을 날짜로 변경하기


```{r}
x = c('2015-07-01', '2015-08-01', '2015-09-01')
x_date = as.Date(x)
str(x_date)
```

`as.Date()` 함수를 이용할 경우, 문자열 형태가 Date로 변경됩니다.

```{r}
y = c('07/01/2015', '08/01/2015', '09/01/2015')
as.Date(y, format = '%m/%d/%Y')
```

YYYY-MM-DD 형태가 아닌 다른 형태로 입력된 경우, format을 직접 입력하여 Date 형태로 변경할 수 있습니다.

```{r}
library(lubridate)
ymd(x)
mdy(y)
```

`lubridate` 패키지를 이용할 경우 YYYY-MM-DD 형태는 `ymd()`, MM-DD-YYYY 형태는 `mdy()` 함수를 사용해 손쉽게 Date 형태로 변경할 수 있습니다. 이 외에도 lubridate에는 Date 형태로 변경하기 위한 다양한 함수가 존재합니다.

```{r, echo = FALSE}
library(kableExtra)

data.frame(
  '순서' = c('year, month, day',
           'year, day, month',
           'month, day, year',
           'day, month, year',
           'hour, minute',
           'hour, minute, second',
           'year, month, day, hour, minute, secod'),
  '함수' = c('ymd()', 'ydm()', 'mdy()', 'dmy()', 'hm()', 'hms()', 'ymd_hms()')
) %>% kable(booktabs = TRUE,
            align = "c") %>%
  kableExtra::kable_styling(bootstrap_options  = c("striped", "hover"))
```

## 날짜 관련 정보 추출

`lubridate` 패키지에는 날짜 관련 정보를 추출할 수 있는 다양한 함수가 존재합니다.

```{r, echo = FALSE}
library(kableExtra)

data.frame(
  '정보' = c('Year', 'Month', 'Week', 'Day of year', 'Day of month',
           'Day of week', 'Hour', 'Minute', 'Second', 'Time zone'),
  '함수' = c('year()', 'month()', 'week()', 'yday()', 'mday()',
           'wday()', 'hour()', 'minute()', 'second()', 'tz()')
) %>% kable(booktabs = TRUE,
            align = "c") %>%
  kableExtra::kable_styling(bootstrap_options  = c("striped", "hover"))
```

```{r}
x = c('2015-07-01', '2015-08-01', '2015-09-01')
```

```{r}
year(x)
month(x)
week(x)
```

`year()`, `month()`, `week()` 함수를 통해 년도, 월, 주 정보를 확인할 수 있습니다.

```{r}
z = '2015-09-15'
```

```{r}
yday(z)
mday(z)
wday(z)
```

`yday()`, `mday()`, `wday()` 함수는 각각 해당 년도에서 몇번째 일인지, 해당 월에서 몇번째 일인지, 해당 주에서 몇번째 일인지를 계산합니다.

```{r}
x = ymd('2015-07-01', '2015-08-01', '2015-09-01') 
x + years(1) - days(c(2, 9, 21))
```

날짜에서 년도와 월, 일자를 더하거나 빼는 계산 역시 가능합니다.

## 날짜 순서 생성하기

`seq()` 함수를 이용할 경우 날짜 벡터를 생성할 수도 있습니다.

```{r}
seq(ymd('2010-01-01'), ymd('2015-01-01'), by ='years')
```

2010년 1월 1일부터 2015년 1월 1일까지 1년을 기준으로 벡터가 생성됩니다.

```{r}
seq(ymd('2010-09-01'), ymd('2010-09-30'), by ='2 days')
```

지정 일수만큼 벡터를 생성할 수도 있습니다.


<!--chapter:end:date.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# (PART) 데이터 구조 다루기 {-}

# Data Structure Basics

R의 데이터구조는 크게 벡터, 리스트, 매트릭스, 데이터프레임으로 나누어집니다. (array는 잘 사용되지 않습니다) 

```{r, echo = FALSE}
library(kableExtra)

data.frame(
  'Dimension' = c('1D', '2D', 'nD'),
  'Homogeneous' = c('Atomic Vector', 'Matrix', 'Array'),
  'Heterogeneous' = c('List', 'Data frame', '')
) %>% kable(booktabs = TRUE,
            align = "c") %>%
  kableExtra::kable_styling(bootstrap_options  = c("striped", "hover"))
```

Homogenous는 컬럼간 데이터 구조가 같은 경우, Heterogeneous는 다른 경우입니다.

## 구조 파악하기

`str()` 함수를 이용해 각 데이터의 구조(structure)를 파악할 수 있습니다.

```{r}
vector = 1:10
list = list(item1 = 1:10, item2 = LETTERS[1:18])
matrix = matrix(1:12, nrow = 4)
df = data.frame(item1 = 1:18, item2 = LETTERS[1:18])
```

```{r}
vector
str(vector)

list
str(list)

matrix
str(matrix)

df
str(df)
```


<!--chapter:end:Data-Structure-Basics.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Vector

벡터는 R의 가장 기본적인 데이터 구조로써 integer, double, logical, character로 이루어져 있습니다.

## 벡터 만들기

```{r}
vec_integer = 8:17
vec_integer

vec_double = c(0.5, 0.6, 0.2)
vec_double

vec_logical = c(TRUE, FALSE, FALSE)
vec_logical

vec_char = c('a', 'b', 'c')
vec_char
```

```{r}
c('a', 'b', 'c', 1, 2, 3)
```

숫자와 문자가 같이 벡터로 묶일 경우, 숫자는 모두 문자 형태로 변경됩니다.

```{r}
c(1, 2, 3, TRUE, FALSE)
```

숫자와 논리값(Logical: TRUE/FALSE)이 같이 묶일 경우 TRUE는 1, FALSE는 0으로 치환된 후 숫자 형태로 변경됩니다.

```{r}
c('a', 'b', 'c', TRUE, FALSE)
```

문자와 논리값이 같이 묶일 경우 모두 문자 형태로 변경됩니다.

## 벡터에 값 추가하기

```{r}
v1 = 8:17
c(v1, 18:22)
```

`c()` 함수를 이용해 기존 벡터에 새로운 값을 추가할 수 있습니다.

## 벡터 추출하기

대괄호([])을 이용해 원하는 부분의 데이터를 추출할 수 있습니다.

```{r}
v1
v1[2]
v1[2:4]
v1[c(2, 4, 6, 8)]
v1[c(2, 2, 4)]
```

대괄호 안에 숫자를 입력시, 벡터에서 해당 순서의 데이터가 추출됩니다. 

```{r}
v1[-1]
v1[-c(2, 4, 6, 8)]
```
마이너스 기호를 입력 시, 해당 순서를 제외한 데이터가 추출됩니다.

```{r}
v1[v1 < 12]
v1[v1 < 12 | v1 > 15]
```

대괄호 내부에 조건을 설정하여 데이터를 추출할 수도 있습니다.



<!--chapter:end:vector.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# List

List 형태는 항목(Element) 간 타입이나 길이가 달라도 데이터가 결합할 수 있습니다. 

## 리스트 생성하기

```{r}
l = list(1:3, 'a', c(TRUE, FALSE, TRUE), c(2.5, 4.2))
str(l)
```

첫번째 리스트는 정수, 두번째는 문자, 세번째는 논리값, 네번째는 숫자로 이루어져 있습니다.

```{r}
l = list(1:3, list(letters[1:5], c(TRUE, FALSE, TRUE)))
str(l)
```

또한 리스트 내에 리스트를 생성하는 것 역시 가능합니다.

## 기존 리스트에 데이터 추가하기

```{r}
l1 = list(1:3, 'a', c(TRUE, FALSE, TRUE))
str(l1)

l2 = append(l1, list(c(2.5, 4.2)))
str(l2)
```

`append()` 함수를 이용해 기존 리스트에 추가로 리스트를 붙일 수 있습니다.

```{r}
l2$item4 = 'new list item'
str(l2)
```

또한 기존 리스트에 달러 사인($)을 입력할 경우, 이름과 함께 리스트가 추가됩니다.

## 리스트 추출하기

리스트 역시 대괄호를 이용해 데이터를 추추할 수 있습니다.

```{r}
l2[1]
l2[c(1,3)]
```

리스트에 이름이 있을 경우, 이를 이용해 추출도 가능합니다.

```{r}
l2['item4']
```

대괄호를 두번, 혹은 달러 사인을 이용해 데이터를 추출할 경우 결과물의 형태는 단순화되어 나타납니다.

```{r}
l2[[1]]
l2$item4
```

특정 리스트에서 항목을 추출하기 위해서는 [[와 [를 함께 사용합니다.

```{r}
l2[[1]]
l2[[1]][3]
```


<!--chapter:end:list.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Matrix

## 행렬 생성하기

```{r}
m1 = matrix(1:6, nrow = 2, ncol = 3)
m1
```

`matrix()` 함수를 이용해 행렬을 생성할 수 있으며, nrow와 ncol을 통해 행과 열 갯수를 지정할 수 있습니다.


```{r}
m2 = matrix(letters[1:6], nrow = 2, ncol = 3)
m2
```

문자 형태로 이루어진 행렬 역시 생성할 수 있습니다. 그러나 숫자와 문자가 한 행렬 내에서 같이 사용될 수는 없습니다.

```{r}
v1 = 1:4
v2 = 5:8
```

```{r}
cbind(v1, v2)
rbind(v1, v2)
```

`cbind()` 함수는 열로 데이터를 합치며, `rbind()` 함수는 행으로 데이터를 합칩니다.

## 기존 행렬에 데이터 추가하기

`cbind()`와 `rbind()` 함수를 이용해 기존 행렬에 데이터를 추가할 수 있습니다.

```{r}
m1 = cbind(v1, v2)
m1
```

```{r}
v3 = 9:12
cbind(m1, v3)
```

## 행이름 및 열이름 추가하기

```{r}
m2 = matrix(1:12, nrow = 4, ncol = 3)
m2
```

```{r}
rownames(m2) = c('row1', 'row2', 'row3', 'row4')
m2
```

```{r}
colnames(m2) = c('col1', 'col2' ,'col3')
m2
```

`rownames()`와 `colnames()` 함수를 이용해 행 및 열이름을 직접 지정할 수 있습니다.

## 행렬 추출하기

행렬 역시 대괄호를 이용해 데이터를 추출할 수 있으며, 공백으로 둘시 모든 행(열)을 선택하게 됩니다.

```{r}
m2
m2[1:2, ]
m2[ , c(1,3)]
m2[1:2, c(1,3)]
```

만일 하나의 열만 선택시 결과가 벡터 형태로 출력되며, drop = FALSE 인자를 추가해주면 행렬의 형태가 유지되어 출력됩니다.

```{r}
m2[, 2]
m2[, 2, drop = FALSE]
```


<!--chapter:end:matrix.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Data Frame

데이터프레임은 R에서 가장 널리 사용되는 형식으로써, 각 컬럼이 다른 클래스를 가질 수 있습니다.

## 데이터프레임 생성하기


```{r}
df = data.frame (col1 = 1:3,
                 col2 = c ("this", "is", "text"),
                 col3 = c (TRUE, FALSE, TRUE),
                 col4 = c (2.5, 4.2, pi))

str(df)
```

col1은 숫자, col2는 팩터, col3는 논리연산자, col4는 숫자로 구성되어 있습니다. R에서는 문자형식을 자동으로 팩터로 인식하며, 이를 원하지 않을 경우 `stringsAsFactors = FALSE`를 입력합니다.

```{r}
df = data.frame (col1 = 1:3,
                 col2 = c ("this", "is", "text"),
                 col3 = c (TRUE, FALSE, TRUE),
                 col4 = c (2.5, 4.2, pi),
                 stringsAsFactors = FALSE)

str(df)
```

또한 벡터 혹은 리스트를 이용해 데이터프레임을 생성할 수도 있습니다.

```{r}
v1 = 1:3
v2 = c ("this", "is", "text")
v3 = c (TRUE, FALSE, TRUE)

data.frame (col1 = v1, col2 = v2, col3 = v3)
```

```{r}
l = list (item1 = 1:3,
          item2 = c ("this", "is", "text"),
          item3 = c (2.5, 4.2, 5.1))

l
```

```{r}
as.data.frame (l)
```

## 기존 데이터프레임에 데이터 추가하기

`cbind()` 함수를 통해 기존 데이터프레임에 새로운 열을 추가할 수 있습니다.

```{r}
df
v4 = c ("A", "B", "C")
```

```{r}
cbind(df, v4)
```

`rbind()` 함수를 사용할 경우 새로운 행을 추가할 수 있습니다. 주의할 점은 각 행의 클래스가 기존 데이터와 일치해야 합니다.

```{r}
v5 = c (4, "R", F, 1.1)
rbind(df, v5)
```

## 데이터프레임추출하기

데이터프레임 역시 대괄호를 이용해 데이터를 추출할 수 있으며, 공백으로 둘시 모든 행(열)을 선택하게 됩니다.

```{r}
df

df[2:3, ]
```

컬럼 이름을 통해 데이터를 선택할 수도있습니다.

```{r}
df[ , c('col2', 'col4')]
```

만일 하나의 열만 선택시 결과가 벡터 형태로 출력되며, drop = FALSE 인자를 추가해주면 데이터프레임의 형태가 유지되어 출력됩니다.

```{r}
df[, 2]
df[, 2, drop = FALSE]
```

<!--chapter:end:dataframe.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Missing Value

데이터 분석에서 결측치를 처리하는 것은 매우 중요하며, R에서 결측치는 `NA`로 표시됩니다. 

## 결측치 테스트

`is.na()` 함수를 통해 결측치 여부를 확인할 수 있습니다.

```{r}
x = c(1:4, NA, 6:7, NA)
x
```
```{r}
is.na(x)
```

NA의 경우 TRUE, 그렇지 않을 경우 FALSE를 반환합니다.

```{r}
df = data.frame (col1 = c (1:3, NA),
                 col2 = c ("this", NA,"is", "text"),
                 col3 = c (TRUE, FALSE, TRUE, TRUE),
                 col4 = c (2.5, 4.2, 3.2, NA),
                 stringsAsFactors = FALSE)

df
```

```{r}
is.na(df)
which(is.na(df))
```

데이터프레임 역시 `is.na()` 함수를 적용할 수 있으며, `which()` 함수를 통해 NA 데이터의 위치를 찾을 수도 있습니다.

## 결측치 제거

### 평균값 대체

```{r}
y = c(1, 3, NA, 4)
y
```

```{r}
mean(y)
```

데이터에 결측치가 존재하면, 일반적인 연산함수의 결과로 NA를 반환합니다.

```{r}
mean(y, na.rm = TRUE)
```

na.rm = TRUE를 추가해주면, NA 데이터를 제외한 나머지 데이터를 대상으로 연산을 합니다.

### 데이터 제거

결측치가 있는 데이터를 삭제해 주는 경우도 있습니다.

```{r}
df = data.frame (col1 = c (1:3, NA),
                 col2 = c ("this", NA,"is", "text"),
                 col3 = c (TRUE, FALSE, TRUE, TRUE),
                 col4 = c (2.5, 4.2, 3.2, NA),
                 stringsAsFactors = FALSE)

df
```

2행과 4행에 NA 데이터가 존재합니다.

```{r}
na.omit(df)
```

`na.omit()` 함수를 이용해 NA가 존재하는 행을 삭제해주도록 합니다.

## 결측치 대체

결측치가 존재할 경우 평균값을 대신 사용하기도 합니다.

```{r}
x
x[is.na(x)] = mean(x, na.rm = TRUE)
x
```

결측치 대신 나머지 값들의 평균인 3.833을 대체하였습니다.



<!--chapter:end:missing-value.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# (PART) 데이터 불러오기 및 내보내기 {-}

# Import Data

데이터 분석의 첫번째 단계는 데이터를 불러오는 것이며, 일반적으로 텍스트 혹은 엑셀 파일로 저장된 데이터를 사용합니다.

아래와 같은 데이터가 각각 csv, excel, RDS 파일로 저장된 예제를 살펴보겠습니다.

```
variable 1, variable 2, variable 3
10,beer,TRUE
25,wine,TRUE
8,cheese,FALSE
```

해당 파일의 주소는 다음과 같습니다.

```
csv: https://github.com/hyunyulhenry/data_wrangling/blob/master/mydata.csv
txt: https://github.com/hyunyulhenry/data_wrangling/blob/master/mydata.txt
excel: https://github.com/hyunyulhenry/data_wrangling/blob/master/mydata.xlsx
rds: https://github.com/hyunyulhenry/data_wrangling/blob/master/mydata.rds
```

먼저 다음 코드를 이용해 해당 파일들을 다운로드 받도록 합니다.

```{r eval = FALSE}
download.file('https://raw.githubusercontent.com/hyunyulhenry/data_wrangling/master/mydata.csv', 'mydata.csv')
download.file('https://raw.githubusercontent.com/hyunyulhenry/data_wrangling/master/mydata.txt', 'mydata.txt')
download.file('https://github.com/hyunyulhenry/data_wrangling/raw/master/mydata.xlsx','mydata.xlsx', mode = 'wb')
download.file('https://github.com/hyunyulhenry/data_wrangling/raw/master/mydata.rds','mydata.rds')
```


## csv 파일 불러오기

먼저 R의 기본함수와 `readr` 패키지를 이용하여 csv 파일을 불러오는 법에 대해 살펴보겠습니다.

### 기본함수

`read.table()` 함수는 데이터를 불러오는 R의 가장 기본인 함수며, `read.csv()`와 `read.delim()` 함수는 특수한 경우의 래퍼 함수라 볼 수 있습니다.

```{r}
mydata = read.csv('mydata.csv')
mydata
str(mydata)
```

먼저 열이름인 variable 다음에 점(.)이 붙은 것이 확인됩니다. 이처럼 기본함수를 사용할 경우 열 이름의 공백은 점으로 바뀌게 됩니다.

또한 variable 2의 문자열이 자동으로 팩터 형태로 바뀌게 되었습니다. 이를 방지하기 위해서는 stringAsFactors를 FALSE로 지정해주어야 합니다.

```{r}
mydata2 = read.csv('mydata.csv', stringsAsFactors = FALSE)
str(mydata2)
```

`read.table()` 함수를 이용하여 csv 데이터를 불러올 수도 있습니다.

```{r}
read.table('mydata.csv', sep = ',', header = TRUE, stringsAsFactors = FALSE)
```

구분자에 해당하는 sep를 ','로 지정해 주며, 열이름에 해당하는 header를 TRUE로 지정해줍니다.

```{r}
read.table('mydata.csv', sep = ',', header = TRUE, stringsAsFactors = FALSE,
           row.names = c('Row 1', 'Row 2', 'Row 3'),
           col.names = c('Var 1', 'Var 2', 'Var 3'))
           
```

row.names와 col.names 인자를 통해 행 및 열이름을 직접 지정할 수도 있습니다.

```{r}
set_classes = read.table('mydata.csv', sep = ',', header = TRUE,
                         colClasses = c('numeric', 'character', 'character'))
str(set_classes)
```

colClasses 인자를 통해 각 열에 해당하는 클래스를 직접 지정해줄 수도 있으며, 2번째 열이 팩터가 아닌 문자 형태로 입력됩니다.

```{r}
read.table('mydata.csv', sep = ',', header = TRUE, nrows = 2)
```

nrows 인자를 통해 전체 데이터가 아닌 지정한 행까지의 데이터만 불러올 수도 있습니다.

### `readr` 패키지

기본 함수 대비 readr 패키지를 이용할 경우 10배 정도 빠르게 데이터를 불러올 수 있습니다.

```{r}
library(readr)
mydata3 = read_csv('mydata.csv')
str(mydata3)
```

`read_csv()` 함수를 이용해 csv 파일을 불러올 수 있습니다. 열이름의 공백이 그대로 유지되며, 문자 형태 역시 팩터가 아닌 원래 형식이 그대로 유지됩니다.

```{r}
read_csv('mydata.csv', col_types = list(col_double(),
                                        col_character(),
                                        col_character()))
```

col_types 인자를 통해 원하는 타입을 직접 입력할 수도 있습니다.

```{r}
read_csv('mydata.csv', col_names = c('Var 1', 'Var 2', 'Var 3'),
         skip = 1)
```

col_names 인자를 통해 열이름을 입력할 수 있으며, skip을 통해 위에서 n번째 행을 건너뛰고 데이터를 불러올 수 있습니다.

```{r}
read_csv('mydata.csv', n_max = 2)
```

n_max 인자를 통해 전체 데이터가 아닌 지정한 행까지의 데이터만 불러올 수도 있습니다.

## 텍스트 파일 불러오기

`.txt` 파일로 저장된 텍스트 파일 역시 `read.delim()` 혹은 `read.table()` 함수를 이용해 불러올 수 있습니다.

```{r}
read.delim('mydata.txt', sep = ',')
```

```{r}
read.table('mydata.txt', sep = ',', header = TRUE)
```

## 엑셀 파일 불러오기

엑셀 파일을 불러오기 위한 패키지는 매우 많으며, 이 중 `xlsx`와 `readxl` 패키지를 살펴보도록 하겠습니다.

### `openxlsx` 패키지

`openxlsx` 패캐지의 `read.xlsx()` 함수를 이용해 엑셀 데이터를 불러올 수 있습니다.

```{r}
library(openxlsx)

read.xlsx('mydata.xlsx', sheet = 'Sheet1')
```

```{r}
read.xlsx('mydata.xlsx', sheet = 'Sheet2')
```

엑셀은 여러 시트로 구성되어 있으므로, sheet 인자를 통해 원하는 시트명의 내용만 불러올 수 있습니다.

```{r}
read.xlsx('mydata.xlsx', sheet = 'Sheet3')
```

간혹 엑셀 파일에는 데이터가 아닌 설명을 위한 텍스트가 적힌 경우도 있으므로, 이를 제외하고 데이터를 불러올 필요가 있습니다.

```{r}
read.xlsx('mydata.xlsx', sheet = 'Sheet3', startRow = 3)
```

startRow 인자를 통해 3번째 행부터 데이터를 불러오게 되어, 불필요한 텍스트가 제거되었습니다.

```{r}
read.xlsx('mydata.xlsx', sheet = 'Sheet3', rows = 3:5)
```
rowIndex 인자를 통해 원하는 행의 데이터만 불러올 수 있습니다.

### `readxl` 패키지

`readxl` 패키지는 `readr` 패키지와 거의 비슷하며, C++을 기반으로 하여 매우 빠른 속도를 자랑합니다.

```{r}
library(readxl)

mydata = read_excel('mydata.xlsx', sheet = 'Sheet5')
mydata
str(mydata)
```

`read_excel()` 함수 역시 sheet 인자를 통해 원하는 시트의 데이터를 불러올 수 있습니다. 빈 칸의 경우 결측치(NA)로 변형되며, 날짜의 경우 POSIXct 형식으로 불러옵니다.

```{r}
read_excel('mydata.xlsx', sheet = 'Sheet5', skip = 1,
           col_names = paste('Var', 1:5))
```

skip 인자를 통해 위에서 n 번째까지 행을 건너뛸 수 있으며, col_names 인자를 통해 원하는 열이름을 직접 입력할 수 있습니다.

간혹 결측치가 NA가 아닌 999와 같은 특정 값으로 입력되는 경우도 있으므로, 이를 찾아 NA로 변형해주어야 합니다.

```{r}
read_excel('mydata.xlsx', sheet = 'Sheet6')
```

```{r}
read_excel('mydata.xlsx', sheet = 'Sheet6', na = '999')
```

NA로 지정하고 싶은 값을 직접 입력할 수 있습니다.

```{r}
read_excel('mydata.xlsx', sheet = 'Sheet5')
```

```{r}
read_excel('mydata.xlsx', sheet = 'Sheet5',
           col_type = c('numeric', 'blank', 'numeric', 'blank', 'date'))
```

col_types 인자를 통해 원하는 클래스를 직접 입력할 수 있으며, blank를 입력할 경우 해당 셀은 불러오지 않습니다.

## R object File

R을 통해 작업한 내용을 csv나 excel 파일이 아닌 Rdata/object 형식(.RData, .rda, .rds)으로 저장하여 공유하는 경우가 있습니다. 

```{r}
readRDS('mydata.rds')
```

각 파일 형식에 따라 `load('mydata.RData)`, `load(file = 'mydata.rda)`, `readRDS(mydata.rds)`와 같은 형태로 데이터를 불러올 수 있습니다.

<!--chapter:end:import-data.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Exporting Data

작업을 마무리 했으면 csv, excel, rds 등의 형태로 데이터를 저장해야 합니다.

## 텍스트, csv 파일 저장하기

먼저 R의 기본함수와 `readr` 패키지를 이용하여 텍스트 파일과 csv 파일로 저장하는 법에 대해 살펴보겠습니다. 먼저 다음과 같이 예제로 사용될 데이터프레임을 만들도록 합니다.

```{r}
df = data.frame(var1 = c(10, 25, 8),
                var2 = c('beer', 'wine', 'cheese'),
                var3 = c(TRUE, TRUE, FALSE),
                row.names = c('billy', 'bob', 'thornton'))

df
```

### 기본함수

`write.csv()` 함수를 통해 csv 파일로 저장할 수 있습니다.

```{r, eval = FALSE}
write.csv(df, file = 'export.csv')
```

`write.delim()` 함수를 사용하여 텍스트 파일로 저장할 수 있습니다.

```{r, eval = FALSE}
write.table(df, file = 'export.txt', sep = '\t')
```

sep를 통해 탭을 구분자로 지정하였습니다.

### `readr` 패키지

`readr` 패키지의 경우 기본 함수에 비해 2배 이상 빠르며, 행 이름을 저장하지 않습니다.

```{r, eval = FALSE}
library(readr)

write_csv(df, 'export2.csv')
```

```{r, eval = FALSE}
write_csv(df, 'export3.csv', col_names = FALSE)
```

col_names 인자를 FALSE로 지정할 경우 열 이름 역시 저장되지 않습니다.

## 엑셀 저장하기

`openxlsx` 패키지를 이용해 엑셀 파일로 저장할 수 있습니다.

```{r, eval = FALSE}
library(openxlsx)

write.xlsx(df, file = 'output_example.xlsx')
```

`openxlsx` 패키지를 이용할 경우 R 내에서 다양한 형식으로 엑셀을 꾸민 후 파일을 저장할 수 있습니다. 자세한 내용은 다음 url을 참조하시기 바랍니다.


## R object File

`saveRDS()` 함수를 통해 작업중인 내용을 RDS 파일로 저장할 수 있습니다.

```{r, eval = FALSE}
saveRDS(df, 'df.rds')
```



<!--chapter:end:export-data.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# (PART) 효율적이고 가독성 높은 코드 {-}

# 함수

반복되는 작업을 매번 복사-붙여넣기 하는 것은 매우 비효율적이며, 함수를 작성하여 사용할 경우 매우 효율적인 작업이 가능합니다.

## 함수의 요소

R에서 함수는 크게 3가지 요소로 구성됩니다.

- `body()`: 함수 내부의 코드
- `formals()`: 인자(argument) 내역
- `environment()`: 함수의 변수에 대한 위치

예를 들어 금융 자산의 현재 가치는 다음과 같이 계산됩니다.

$$PV = FV / (1+r)^n$$

- PV: 현재 가치
- FV: 미래 가치
- r: 할인률
- n: 기간

이를 함수로 나타내면 다음과 같습니다.

```{r}
PV = function(FV, r, n) {
  PV = FV / (1+r)^n
  round(PV, 2)
}
```

3가지 요소를 확인해보도록 하겠습니다.

```{r}
body(PV)
formals(PV)
environment(PV)
```

## 인자

`PV()` 함수는 여러 방법으로 실행할 수 있습니다.

```{r}
PV(FV = 1000, r = 0.08, n = 5)
```

모든 인자 리스트와 이에 대응되는 값을 입력합니다.

```{r}
PV(1000, 0.08, 5)
```

인자 리스트를 생략하면, 순서대로 값이 입력됩니다.

```{r}
PV(r = 0.08, FV = 1000, n = 5)
```

인자 내역을 순서대로 입력하지 않아도 됩니다.

```{r error=TRUE}
PV(1000, 0.08)
```

`PV()` 함수에 필요한 인자는 3개인 반면, 2개만 입력하였으므로 에러가 발생합니다.

```{r}
PV = function(FV = 1000, r = .08, n = 5) {
  PV = FV / (1 + r)^n
  round(PV, 2)
}

PV(1000, 0.08)
```

만일 함수의 인자에 디폴트 값이 입력되어 있다면, 함수 실행시 이를 생략하여도 디폴트 값이 입력됩니다. 위 예제에서 n값이 디폴트 값인 5가 적용되었습니다.

## 다중 결과값 출력

동일한 함수를 여러값에 적용하기 위해서는 함수 내부에 `c()` 함수를 적용해야 합니다.

```{r}
bad = function(x, y) {
  2 * x + y       # 1
  x + 2 * y       # 2
  2 * x + 2 * y   # 3  
  x / y           # 4
}

bad(1, 2)
```

1, 2, 3, 4번 모든 연산에 대한 출력을 원하지만, 맨 마지막 연산값 만이 출력됩니다.

```{r}
good = function(x, y) {
  output1 = 2 * x + y
  output2 = x + 2 * y
  output3 = 2 * x + 2 * y
  output4 = x / y
  c(output1, output2, output3, output4)
}

good(1, 2)
```

모든 결과를 output*에 저장한 후 `c()` 함수를 통해 이를 묶어주면, 모든 연산값이 출력됩니다.



<!--chapter:end:function.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Loop Statement

루프 구문을 사용할 경우 반복된 작업을 간단히 수행할 수 있습니다. 

## 기본 제어 구문 (`if`, `for`, `while` 등)

### `if` 구문

if 구문은 다음과 같이 구성됩니다.

```{r eval = FALSE}
if (test_expression) {
  statement
}
```

괄호 안의 test_expression이 TRUE일 경우에만 statement 코드가 실행됩니다.

```{r}
x = c(8, 3, -2, 5)

if (any(x < 0)) {
  print('x contains negative number')
}
```

만일 x중 음수가 존재하면 *x contains negative number*가 출력되는 조건이며, -2가 음수이므로 조건을 만족합니다.

```{r}
y = c (8, 3, 2, 5)

if (any (y < 0)) {
  print ("y contains negative numbers")
}
```

y에는 음수가 존재하지 않으므로, 구문이 실행되지 않습니다.

### `if...else` 구문

if 구문만 존재할 시 이를 만족하지 않는 경우 아무런 구문도 실행되지 않습니다. if else 구문의 경우 조건을 만족하지 않을 경우 else에 해당하는 구문이 실행됩니다.

```{r eval = FALSE}
if (test_expression) {
  statement 1
} else {
  statement 2
}
```

만일 test_expression 구문이 TRUE이면 statement 1이 실행되며, 그렇지 않을 경우 statement 2가 실행됩니다.

```{r}
y = c (8, 3, 2, 5)

if (any (y < 0)) {
  print ("y contains negative numbers")
} else {
  print ("y contains all positive numbers")
}
```

y에 음수가  존재하는 if구문이 FALSE 이므로, else에 해당하는 메세지가 출력됩니다.

if...else 구문은 `ifelse()` 함수로 간단히 나타낼 수도 있습니다.

```{r}
x = c (8, 3, 2, 5)

ifelse(any(x < 0), "x contains negative numbers", "x contains all positive numbers")
```

또한 if와 else 사이에 else if 조건을 통해, 여러 조건을 추가할 수도 있습니다.

```{r}
x = 7

if (x >= 10) {
  print ("x exceeds acceptable tolerance levels")
} else if(x >= 0 & x < 10) {
  print ("x is within acceptable tolerance levels")
} else {
  print ("x is negative")
}
```

위 조건은 다음과 같습니다.

1. x가 10 이상일 경우 **x exceeds acceptable tolerance levels**을 출력합니다.
2. 만일 x가 10 이상, 10 미만일경우 **x is within acceptable tolerance levels**을 출력합니다.
3. 그렇지 않을 경우 **x is negative**을 출력합니다.

x는 7 이므로 else에 해당하는 내용이 출력됩니다. 

### `for loop`

for loop 구문은 특정한 부분의 코드가 반복적으로 수행될 수 있도록 합니다. 

```{r eval = FALSE}
for (i in 1:100) {
  <code: do stuff here with i>
}
```

먼저 i에 1이 들어간 뒤 code에 해당하는 부분이 실행됩니다. 그 후, i에 2가 들어간 뒤 다시 code가 실행되며 이 작업이 100까지 반복됩니다. 실제 예제를 살펴보도록 하겠습니다.

```{r}
for (i in 2010:2016) {
  output = paste("The year is", i)
  print(output)
}
```

i에 2010부터 2016 까지 대입되어 코드가 실행됩니다.

### `while loop`

while 구문은 for 구문과 비슷하며, 조건이 충족되는한 루프가 계속해서 실행됩니다.

```{r eval = FALSE}
counter = 1

while (test_expression) {
  statement
  counter = counter + 1
}
```

test_expression이 TRUE이면 statement 코드가 실행되며, counter를 1씩 더합니다. 즉, test_expression이 FALSE가 될때까지 loop가 반복됩니다.

```{r}
counter = 1

while (counter <= 5) {
  print(counter)
  counter = counter + 1
}
```

counter가 5 이하일 경우 이를 출력하며, 6일 경우 test_expression이 FALSE가 되어 loop가 멈추게 됩니다.

### `next`

next 명령어는 loop 구문에서 특정 단계를 실행하지 않고 넘어가기 위해 사용됩니다.

```{r}
x = 1:5

for (i in x) {
  if (i == 3) {
    next
  }
  print(i)
}
```

일반적인 for loop 구문으로써 i를 출력하며, if 구문을 통해 i가 3일 경우 명령을 실행하지 않고 다음 for 구문(i = 4)으로 건너뜁니다.

## Apply 계열 함수

apply 계열 함수는 loop 구문과 비슷한 역할을 하며, 훨씬 간결하게 표현할 수 있습니다.

### `apply()`

`apply()` 함수는 매트릭스나 데이터프레임의 행 혹은 열단위 계산에 자주 사용됩니다. 해당 함수는 다음과 같이 구성됩니다.

```{r eval = FALSE}
apply(x, MARGIN, FUN, ...)
```
- x: 매트릭스, 데이터프레임, 혹은 어레이
- MARGIN: 함수가 적용될 벡. 1은 행을, 2는 열을, c(1, 2)는 행과 열을 의미
- FUN: 적용될 함수
- ...: 기타

```{r}
head(mtcars)
```

```{r}
apply(mtcars, 2, mean)
```

mtcars 데이터에서 2, 즉 열의 방향으로 평균(mean)을 구합니다.

```{r}
apply(mtcars, 1, sum)
```

이번에는 1 즉 행의 방향으로 합계(sum)를 구합니다.

```{r}
apply(mtcars, 2, quantile, probs = c(0.10, 0.25, 0.05, 0.75, 0.90))
```

각 열의 분위수(quantile)를 구하게 되며, 분위는 probs 인자를 통해 직접 입력할 수 있습니다.

### `lapply()`

`lapply()` 함수는 리스트에 적용되며, 결과 또한 리스트로 반환됩니다. 해당 함수는 다음과 같이 구성됩니다.

```{r eval = FALSE}
lapply(x, FUN, ...)
```
- x: 리스트
- FUN: 적용될 함수
- ...: 기타

```{r}
data = list(item1 = 1:4,
            item2 = rnorm(10),
            item3 = rnorm(20, 1),
            item4 = rnorm(100, 5))

data
```

```{r}
lapply(data, mean)
```

`lapply()` 함수를 통해 각 항목의 평균을 구하며, 결과 또한 리스트 형태입니다.

```{r}
beaver_data = list(beaver1 = beaver1, beaver2 = beaver2)

lapply(beaver_data, head)
```

위 데이터의 각 항목에서 열 별 평균을 구하고자 할 경우 `lapply()` 함수 만으로는 계산이 불가능합니다. 이러한 경우 해당 함수 내부에 직접 `function()`을 정의하여 복잡한 계산을 수행할 수 있습니다.

```{r}
lapply(beaver_data, function(x) {
  round(apply(x, 2, mean), 2)
})
```

`function(x)`를 통해 각 항목에 적용될 함수를 직접 정의할 수 있으며, 열의 방향으로 평균을 구한 뒤 소수 둘째 자리까지 반올림을 하게 됩니다.

### `sapply()`

`sapply()` 함수는 `lapply()` 함수와 거의 동일하며, 결과가 리스트가 아닌 벡터 혹은 매트릭스로 출력된다는 점만 차이가 있습니다.

```{r}
lapply(beaver_data, function(x) {
  round(apply(x, 2, mean), 2)
})
```

```{r}
sapply(beaver_data, function(x) {
  round(apply(x, 2, mean), 2)
})
```

## 기타 함수

열과 행이 합계나 평균을 구할 때는 `apply()` 함수보다 간단하게 표현할 수 있는 함수들이 있습니다.

```{r}
rowSums(mtcars)
colSums(mtcars)
```

`rowSums()` 함수는 행의 합계를, `colSums()` 함수는 열의 합계는 구하며 이는 `apply(mtcars, 1 or 2, sum)` 과 동일합니다.

```{r}
rowMeans(mtcars)
colMeans(mtcars)
```

`rowMeans()`와 `colMeans()` 함수 역시 각각 행과 열의 평균을 구합니다.

<!--chapter:end:loop.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# Pipe Operator (`%>%`)

`magrittr` 패키지는 코드의 가독성을 높이는 다양한 오퍼레이터를 제공합니다.

## Pipe Operator (`%>%`)

파이프 오퍼레이터는 R에서 동일한 데이터를 대상으로 연속으로 작업하게 해주는 오퍼레이터(연산자)입니다. 크롤링에 필수적인 rvest 패키지를 설치하면 자동으로 magrittr 패키지가 설치되어 파이프 오퍼레이터를 사용할 수 있습니다.

흔히 프로그래밍에서 x라는 데이터를 F()라는 함수에 넣어 결괏값을 확인하고 싶으면 F(x)의 방법을 사용합니다. 예를 들어 3과 5라는 데이터 중 큰 값을 찾으려면 `max(3,5)`를 통해 확인합니다. 이를 통해 나온 결괏값을 또 다시 G()라는 함수에 넣어 결괏값을 확인하려면 비슷한 과정을 거칩니다. `max(3,5)`를 통해 나온 값의 제곱근을 구하려면 `result = max(3,5)`를 통해 첫 번째 결괏값을 저장하고, `sqrt(result)`를 통해 두 번째 결괏값을 계산합니다. 물론 `sqrt(max(3,5))`와 같은 표현법으로 한 번에 표현할 수 있습니다.

이러한 표현의 단점은 계산하는 함수가 많아질수록 저장하는 변수가 늘어나거나 괄호가 지나치게 길어진다는 것입니다. 그러나 파이프 오퍼레이터인 %>%를 사용하면 함수 간의 관계를 매우 직관적으로 표현하고 이해할 수 있습니다. 이를 정리하면 아래 표와 같습니다.

```{r mag, echo = FALSE}
knitr::kable(
  data.frame(
  '내용' = c('F(x)', 'G(F(x))'),
  '표현 방법' = c('x %>% F', 'x %>% F %>% G')
  ),
  booktabs = TRUE,
  align = "c",
  caption = '파이프 오퍼레이터의 표현과 내용 비교'
) %>%
  kableExtra::kable_styling(latex_options = c("striped", "hold_position"))
```

간단한 예제를 통해 파이프 오퍼레이터의 사용법을 살펴보겠습니다. 먼저 다음과 같은 10개의 숫자가 있다고 가정합니다.

```{r}
x = c(0.3078, 0.2577, 0.5523, 0.0564, 0.4685,
      0.4838, 0.8124, 0.3703, 0.5466, 0.1703)
```

우리가 원하는 과정은 다음과 같습니다.

1. 각 값들의 로그값을 구할 것
2. 로그값들의 계차를 구할 것
3. 구해진 계차의 지수값을 구할 것
4. 소수 둘째 자리까지 반올림할 것

입니다. 즉 `log()`, `diff()`, `exp()`, `round()`에 대한 값을 순차적으로 구하고자 합니다.

```{r}
x1 = log(x)
x2 = diff(x1)
x3 = exp(x2)
round(x3, 2)
```

첫 번째 방법은 단계별 함수의 결괏값을 변수에 저장하고 저장된 변수를 다시 불러와 함수에 넣고 계산하는 방법입니다. 전반적인 계산 과정을 확인하기에는 좋지만 매번 변수에 저장하고 불러오는 과정이 매우 비효율적이며 코드도 불필요하게 길어집니다.

```{r}
round(exp(diff(log(x))), 2)
```

두 번째는 괄호를 통해 감싸는 방법입니다. 앞선 방법에 비해 코드는 짧아졌지만, 계산 과정을 알아보기에는 매우 불편한 방법으로 코드가 짜여 있습니다.

```{r}
library(magrittr)
x %>% log() %>% diff() %>% exp() %>% round(., 2)
```

마지막으로 파이프 오퍼레이터를 사용하는 방법입니다. 코드도 짧으며 계산 과정을 한눈에 파악하기도 좋습니다. 맨 왼쪽에는 원하는 변수를 입력하며, %>% 뒤에는 차례대로 계산하고자 하는 함수를 입력합니다. 변수의 입력값을 ()로 비워둘 경우, 오퍼레이터의 왼쪽에 있는 값이 입력 변수가 됩니다. 반면 `round()`와 같이 입력값이 두 개 이상 필요하면 마침표(.)가 오퍼레이터의 왼쪽 값으로 입력됩니다.

파이프 오퍼레이터는 크롤링뿐만 아니라 모든 코드에 사용할 수 있습니다. 이를 통해 훨씬 깔끔하면서도 데이터 처리 과정을 직관적으로 이해할 수 있습니다.

<!--chapter:end:pipe.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# (PART) 데이터 구조 변형하기 {-}

# `tidyr`을 이용한 데이터 모양 바꾸기

깔끔한 데이터(tidy data)는 다음과 같이 구성되 있습니다.

1. 각 변수(variable)는 열로 구성됩니다.
2. 각 관측값(observation)은 행으로 구성됩니다.
3. 각 타입의 관측치는 테이블을 구성합니다.

```{r echo = FALSE, fig.cap='tidy 데이터 요건'}
knitr::include_graphics('images/tidy_data.png')
```

`tidyr` 패키지는 이러한 깔끔한 데이터를 만드는데 필요한 여러 함수가 있습니다.

## 세로로 긴 데이터 만들기

먼저 가로로 긴(Wide) 데이터를 세로로 길게 만드는데는 `gather()` 함수가 사용됩니다. 이 함수는 여러 열을 key-value 페어로 변형해줍니다.

```{r}
library(tidyr)

table4a
```

세 국가의 1999, 2000년 데이터가 있습니다. 이 중 country를 제외한 연도별 데이터를 세로로 길게 만들도록 하겠습니다.

```{r}
long = table4a %>% gather(key = years, value = cases, -country)

print(long)
```

열 이름에 해당하던 데이터가 year 열에 들어왔으며, 관측치에 해당하는 값이 cases 열에 왔습니다.

```{r echo = FALSE}
library(knitr)
library(kableExtra)

list(table4a, long) %>% kable() %>% kable_styling("striped")
```


## 가로로 긴 데이터 만들기

`gather()` 함수와 반대로, `spread()` 함수를 이요할 경우 세로로 긴 데이터를 가로로 길게 만들 수 있습니다. 위의 데이터에 year 열에 있는 항목들을 열 이름으로, cases 열에 있는 항목들을 가로로 길게 되돌려야 합니다.

```{r}
back2wide = long %>% spread(years, cases)

back2wide
```

원래와 동일한 데이터로 되돌아 왔습니다.

## 하나의 열을 여러 열로 나누기

```{r}
table3
```

rate 열에는 ###/#### 형태로 데이터가 들어가 있습니다. 이를 / 기준으로 앞과 뒤로 각각 나누어보도록 하겠습니다.

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"))
```

rate 열이 "/"를 기준으로 cases와 population 열로 분리되었습니다.

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), remove = FALSE)
```

remove = FALSE를 추가해주면 원래의 열을 유지합니다.

## 여러 열을 하나로 합치기

`separate()` 함수와는 반대로, `unite()` 함수를 이용시 여러 열을 하나로 합칠 수 있습니다.

```{r}
table5
```

century와 year 열을 하나로 합쳐보도록 하겠습니다.

```{r}
table5 %>% 
  unite(new, century, year, sep = "")
```

new 열에 지정한 데이터가 합쳐지게 됩니다. 

```{r}
table5 %>% 
  unite(new, century, year, sep = "_")
```

sep 인자를 통해 구분자를 선택할 수도 있습니다.

## `tidyr`의 기타 함수

### `fill()`

많은 부분이 결측치로 비어 있으므로, 이를 채워줄 필요가 있습니다.

```{r}
treatment = tribble(
  ~ person,           ~ treatment, ~response,
  "Derrick Whitmore", 1,           7,
  NA,                 2,           10,
  NA,                 NA,           9,
  "Katherine Burke",  1,           4
)

treatment
```

treatment의 2번째와 3번째 행에 `NA` 데이터가 있어 이를 채워줄 필요가 있습니다.

```{r}
treatment %>% 
  fill(person, treatment)
```

`fill()` 함수는 결측치가 있을 경우, 각 열의 이전 데이터를 이용해 채워줍니다.

### `replce_na()`

NA 데이터를 특정 값으로 변경할 수도 있습니다.

```{r}
treatment %>% replace_na(replace = list (person = "unknown"))
```

`replace_na()` 함수를 이용해 person 열의 NA 데이터를 **unknown**으로 변경하였습니다.

```{r}
treatment %>% replace_na(replace = list (person = "unknown", treatment = 1))
```

각 열마다 서로 다른 값으로 변경할 수 있습니다.

<!--chapter:end:tidyr.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(123)

knitr::opts_chunk$set(
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618,  # 1 / phi
  fig.show = 'hold',
  warning = FALSE,
  message = FALSE
)

if(!knitr:::is_html_output()) {
  options("width"=56)
  knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
    )
  knitr::opts_chunk$set(fig.pos = 'h')
}

pdf.options(family = "Korea1deb")
options(scipen = 5)
options(digits = 4)
```
# `dplyr`을 이용한 데이터 변형하기

데이터를 필터링 하거나, 요약하거나, 정렬하거나, 새로운 변수를 만드는 등 데이터 분석을 위해서는 데이터 변형하고 가공해야 하는 경우가 많습니다. R의 기본 함수도 이러한 기능을 제공하지만. `dplyr` 패키지를 이용할 경우 훨씬 빠르고 효율적으로 업무를 처리할 수 있습니다.

nycflights13 패키지의 flights 데이터셋을 예제로 사용하도록 하겠습니다.

```{r}
library(dplyr)
library(nycflights13)

flights
```

## `select()`: 원하는 열 선택하기

`select()` 함수를 이용해 특정 열만을 선택할 수 있습니다.

```{r}
flights %>% select(year, month, day)
```

year, month, day 열을 선택했습니다.

```{r}
flights %>% select(year:day)
```

콜론(:)을 이용해 year부터 day 까지의 열을 한번에 선택할 수도 있습니다.

```{r}
flights %>% select(-(year:day))
```

마이너스(-)를 이용할 경우 해당 열을 제외한 모든 열이 선택됩니다.

```{r}
flights %>% select(starts_with("dep"))
```

`select()` 함수 내에 `starts_with()` 함수를 이용할 경우, 해당 문자로 시작하는 열을 모두 선택할 수 있습니다.

## `rename()`: 이름 새로 부여하기

```{r}
flights %>% rename(tail_num = tailnum) %>% select(tail_num)
```

`rename()` 함수를 이용해 tailnum 이던 열 이름을 tail_num 으로 변경하였습니다.

## `filter()`: 필터링

특정 열에 원하는 데이터가 있는 부분만 필터링을 해야하는 경우가 많으며, `filter()` 함수를 사용해 손쉽게 해결할 수 있습니다.

```{r}
flights %>% filter(month == 1, day == 1)
```

month 열이 1이고, day 열이 1인 부분만 선택되었습니다.

## `group_by()`: 원하는 조건으로 그룹화

각 그룹별 통계량을 계산할 때는 `group_by()` 함수를 통해 그룹을 묶고, 계산하는 것이 편합니다.

```{r}
by_day = group_by(flights, year, month, day)

by_day
```

Division을 기준으로 그룹을 묶었습니다. 아직 계산을 하지 않았으므로 데이터프레임 자체는 원래와 동일하며, **Groups**를 통해 어떠한 조건으로 그룹이 묶여있는지 확인됩니다.

## `summarize()`: 요약값 계산하기

요약 통계값은 `summarize()` 함수를 통해 쉽게 계산할 수 있습니다.

```{r}
by_day %>% summarise(delay = mean(dep_delay, na.rm = TRUE))
```

각 그룹 별 dep_delay의 평균을 구하며, `na.rm` 인자를 TRUE로 설정하여 `NA` 데이터는 제거해 줍니다.

```{r}
flights %>% group_by(dest) %>%
  summarize(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
)
```

한 번에 여러 통계량을 계산할 수도 습니다. `n()`은 전체 행 갯수를 의미합니다. `group_by()`를 통해 그룹으로 묶여진 데이터에 `summarize()` 함수를 적용할 경우, 그룹 별 통계량이 계산됩니다.

## `arrange()`: 데이터 정렬하기

`arrange()` 함수를 통해 원하는 열을 기준으로 데이터를 순서대로 정렬할 수 있으며, 오름차순을 기본으로 합니다.

```{r}
flights %>% arrange(year, month, day)
```

[year -> month -> day] 순으로 내림차순 정렬이 됩니다.

```{r}
flights %>% arrange(desc(dep_delay))
```

`arrange()` 내에 `desc()` 함수를 추가할 경우 내림차순으로 정렬됩니다.

## join(): 데이터 합치기

각기 다른 데이터를 하나로 합치기 위해서는 join 함수를 사용해야 합니다. `dplyr`에는 다양한 관련 함수가 있습니다.

- `inner_join()`
- `left_join()`
- `right_join()`
- `full_join()`
- `semi_join()`
- `anti_join()`

다음 두개의 데이터 테이블을 이용하도록 합니다.

```{r}
flights2 = flights %>% 
  select(year:day, hour, tailnum, carrier)

flights2

airlines
```

`left_join()` 함수를 이용해 왼쪽 데이터프레임을 기준으로 합쳐보도록 합니다. 두 데이터 모두 carrier 열이 있으므로 이를 기준으로 데이터가 합쳐집니다.

```{r}
flights2 %>%
  left_join(airlines, by = "carrier")
```

flights2의 모든 데이터를 가져오며, airlines의 name 열이 기존 테이블에 추가됩니다. join 구문에 대한 더욱 상세한 예제 및 애니메이션은 다음 주소를 참조하시기 바랍니다.

https://github.com/gadenbuie/tidyexplain

## `mutate()`: 새로운 열 생성하기

`mutate()` 함수를 사용해 기존 열끼리 계산을 하여 새로운 열을 생성할 수 있습니다.

```{r}
flights_sml = flights %>%
  select(
    year:day, 
    ends_with("delay"), 
    distance, 
    air_time
)

flights_sml %>% mutate(
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)

```

먼저 flights에서 일부 열을 선택한 후, `mutate()` 함수를 이용해 새로운 열을 만들어 줍니다. gain 열에는 dep_delay와 arr_delay의 차이가, speed 열에는 distance와 air_time 비에 60을 곱한 값이 새롭게 생성됩니다.

<!--chapter:end:dplyr.Rmd-->

